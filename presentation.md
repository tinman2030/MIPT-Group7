# Slide 1 - Intro
Hello everyone, I'm here to present to you our Canadian Smart Water​, so let's get right into it, starting with the formulation of our problem
# Slide 2 - The Prompt
It states "Say the prompt". And I just want to go over some definitions so this computer talk to catch all you physics people up on the hottest Computer Science slang. ***Quickly go over the definitions of everything***. My favourite, most mind-blowing thing about the NP-Complete and NP-Hard problems is that if any problem in either/or both of the sets is found to have a polynomial time algorithm, then due to the special bond between the them and the reducivity of NP problems, ALL NP problems can be reduced down to polynomial time!!!! That's why these are so studied, solving one can proved if P = NP. And so we're going to hone in on one of these, that being the subset sum problem
# Slide 3 - The Problem
The idea behind it is that given a multiset of integers, and a target integer, is there a subset of the multiset whose sum is equal to said target. This will only be a decision problem, where we only need to find 1 subset and just answering YES, there is. It’s a very simple problem, but I'm levels below simple minded, so I had to dumb it down for myself. I did this by adding a restriction in which we would only use a multiset consisting of positive integers. This is a valid NP-hard variation of the problem and is also NP-complete, thus it has a polynomial time verifier, as you can see `here`. So, I want to do an example for y'all, get some audience participation, keep you on your toes. Given this multiset and this target, is there a valid subset? Who can find one first? ***Someone finds it***. Awesome job, how did you do it?​
# Slide 4 - The Algorithm
Well, this is our Naïve, simple minded algorithm. This is probably the most intuitive, and most brute force way to do this. We get all 2^n combinations where n is the size of the multiset, then take all of their sums, which depending on how you do it can be a whole new can of worms. Yeah, so basically the idea is to get all possible combinations with 2 or more items, then take their sums and compare all of them. This is a grotesquely inefficient algorithm. Summing the 2^n combinations is a time consuming process. This is what the video was demonstrating. This is the showing the running time of based on the size of input multiset. As you can see the running exponentially increases! Going up to a running time of over 1 second, and that's where my patience ran dry with my computer. But as you can imagine, or extrapolate via the fitted curve, this takes a long time given a larger multi. Taking the equation from the last sample points we get that with a set of 27 integers would take a year to compute a set of with 30 would take a century, 32 would take 1000 years, and you get the idea. So this is really bad, wildly inefficent, and time consuming, so it seemed the obvious choice for us to use for our computer. There are more efficient algorithms, all still exponential time, but have reduced coefficients. They're not relevant to the presentation, so if you're interested about them you can talk to me after.​
# Slide 5 - The Solution I
Now is the exciting part. This is where the water comes in. Our idea for implementing this algorithm with a water based computer goes as such:

- We take our list of integers and convert them into binary
- We then, on the basis of a pythagorean/greedy siphon we construct `and`, `xor`, and `or` gates to use in a half adder as `such`, then use the half adders to make a full adder, and then conjoin the full adders to make an n-bit ripple adder.
- Taking an n-bit ripple adder we can then connect it's output into the input of another row of ripple adders, to be able to sequentially take the sum of the entire input set.
- This is especially cool since this is how computers do addition, with the exception for a lack of a look ahead feature which makes it a lot slower, but thus is the restriction of water.
